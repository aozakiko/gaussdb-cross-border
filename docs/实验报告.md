# GaussDB 综合实验报告

## 1. 实验目标

1. **本地 CentOS 虚拟机**：基于源码部署一主两备 GaussDB（或 openGauss）集群。
2. **云端容器环境**：借助 Docker Compose 构建伪分布式 GaussDB 服务，便于快速复现与练习。
3. **Web 应用**：采用 Python (FastAPI) + 原生前端，完成 CRUD、过滤、Flink 批处理分析，所有 UI 控件对应后端逻辑。
4. **容器化**：为前后端分别构建 Docker 镜像，支持在云开发者空间或本地环境部署。
5. **总结**：沉淀安装、配置、联调与运维全过程。

---

## 2. 本地 CentOS 一主两备部署

1. **依赖准备**

```bash
yum groupinstall -y "Development Tools"
yum install -y bison flex libaio-devel ncurses-devel readline-devel
```

2. **获取源码并编译**

```bash
useradd -m gaussdb && su - gaussdb
git clone https://gitee.com/opengauss/openGauss-server.git
cd openGauss-server && bash build.sh -m release
```

3. **初始化主库**

```bash
export GAUSS_HOME=/opt/gaussdb
source $GAUSS_HOME/script/gs_profile
mkdir -p /data/gauss/primary

gs_initdb -D /data/gauss/primary -w 'Gaussdb@123' --nodename=primary
```

4. **配置备库**：在 standby1/standby2 上分别执行 `gs_initdb`，编辑 `postgresql.conf` 与 `pg_hba.conf`，确保 `wal_level=hot_standby`，`primary_conninfo` 指向主节点。

5. **启动集群**

```bash
gs_ctl start -D /data/gauss/primary
gs_ctl build -D /data/gauss/standby1 -Z single_node -b full
```

6. **验证**：`gs_om -t status --detail` 应显示一个 `Normal` primary 与两个 `Normal` standby。

---

## 3. 云端伪分布式部署（Docker Compose）

`docker/gaussdb-pseudo-distributed.yml` 通过 3 个容器模拟主备架构，主要要点：

- 统一桥接网络 `gauss-net`，互通主备。
- `GS_ROLE`、`GS_PRIMARY_HOST` 等环境变量控制角色。
- 通过挂载卷持久化数据，便于重启。
- 启动后在主节点执行 `gs_ctl build -b full` 初始化备库。

在云开发者空间执行：

```bash
cd docker
docker compose -f gaussdb-pseudo-distributed.yml up -d
```

---

## 4. Web 应用设计

### 4.1 架构

```
前端 (HTML/CSS/JS)  <->  FastAPI (REST)  <->  GaussDB (SQLAlchemy)  <->  Flink (PyFlink Table API)
```

- **后端**：`backend/app` 使用 FastAPI + SQLAlchemy + Pydantic，提供 `/records` CRUD、`/records/analytics/flink`，并额外在根路径 `/` 集成了基于 Jinja2 的可视化控制台（表单增删改查 + 状态环形图 + 实时统计），即使在没有前端 SPA 的场景下也能直接在后端界面管理 GaussDB 数据。
- **数据库层**：`app/database.py` 动态读取 `.env` 或环境变量，可无缝切换至 GaussDB 主机；单测默认使用 SQLite。
- **大数据分析**：`app/services/flink_job.py` 通过 PyFlink Table API 统计 `status` / `owner` 分布，并内置 SQL 降级逻辑。
- **前端**：`frontend/index.html` + `app.js` + `styles.css`，所有按钮、表单均映射到具体 API 请求。

### 4.2 关键 API 契约

| Method | Path | 描述 |
| ------ | ---- | ---- |
| GET | `/records/` | 分页 + 过滤查询 |
| POST | `/records/` | 新增记录 |
| GET | `/records/{id}` | 查看详情 |
| PUT | `/records/{id}` | 更新记录 |
| DELETE | `/records/{id}` | 删除记录 |
| GET | `/records/analytics/flink` | 触发 Flink 统计 |

---

## 5. Docker 镜像制作

1. **后端**：`backend/Dockerfile` 基于 `python:3.11-slim`，安装 `requirements.txt`，暴露 8000 端口。
2. **前端**：`frontend/Dockerfile` 使用 `nginx:alpine`，复制静态资源至默认目录。
3. **一体化编排**：根目录 `docker-compose.yml` 将 `gaussdb`、`backend`、`frontend` 编排在同一网络，可直接 `docker compose up --build` 运行。

---

## 6. Flink 接入

- 示例默认启用 PyFlink Table API，作业名称和并行度可由 `FLINK_JOB_NAME`、`FLINK_PARALLELISM` 控制。
- 若运行环境缺少 PyFlink，服务会自动降级到 SQL 统计，并在响应中标注 `engine=sql_fallback`，方便排障。
- 如需外接独立 Flink 集群，可将本地 Table API 改为提交 `pyflink` 作业，或使用 JDBC/CDC Connector 直接读取 GaussDB。

---

## 7. 功能验证

1. **接口测试**：`backend/tests/test_records.py` 使用 FastAPI TestClient + SQLite 内存库，可 `pytest` 快速回归。
2. **前端联调**：在浏览器打开 `frontend/index.html`，设置 API 地址，验证新增/编辑/删除/过滤功能。
3. **Flink 路径**：安装 `pyflink` 并设置 `FLINK_PARALLELISM`，点击前端“运行 Flink 汇总”按钮，观察返回 JSON；若环境不存在 PyFlink，会提示降级。

---

## 8. 运维与接入现有集群

- 将 `GAUSS_HOST` 指向主节点 VIP，同时设置备节点只读 DSN，借助连接池实现自动重连。
- 利用 `gs_ctl query` 或 SQL 监控 `pg_stat_replication`，并在 FastAPI 中加健康检查 `/health`。
- 可将镜像推送至企业私有仓库，在云开发者空间触发 CI/CD；前端 Nginx 可通过 `envsubst` 注入后端地址。

---

## 9. 结论与展望

本实验完成了从数据库集群搭建、容器化编排到 Web 全栈与 Flink 分析的一条龙流程，满足实验题目 7 项要求。后续可扩展：

- 引入 Flink CDC 做实时指标
- 集成 Keycloak/OpenID 统一认证
- 使用 Helm Chart 在 K8s 上部署，实现弹性伸缩与滚动升级
